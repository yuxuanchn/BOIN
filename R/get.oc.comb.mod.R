#'
#' Generate operating characteristics for drug combination trials
#'
#' Obtain the operating characteristics of the BOIN design for drug combination
#'  trials. The BOIN design is to find a MTD.
#'
#' @usage get.oc.comb.mod(target, p.true, ncohort, cohortsize, n.earlystop=NULL, startdose=c(1, 1),
#'                    titration=FALSE,p.saf=0.6*target, p.tox=1.4*target, cutoff.eli=0.95,
#'                    extrasafe=FALSE,offset=0.05, ntrial=1000, mtd.contour=FALSE,
#'                    boundMTD=FALSE, seed=6)
#'
#' @param target the target DLT rate
#' @param p.true a \code{J*K} matrix \code{(J<=K)} containing the true toxicity probabilities of
#'               combinations with \code{J} dose levels of agent A and \code{K} dose levels of agent B
#' @param ncohort a \code{1*J} vector specifying the number of cohorts for each of \code{J} subtrials
#'                if \code{mtd.contour=TRUE}; Otherwise, a scalar specifying the total number of cohorts for
#'                the trial.
#' @param cohortsize the cohort size
#' @param n.earlystop the early stopping parameter. If the number of patients treated at the current
#'                    dose reaches \code{n.earlystop}, stop the trial or subtrial and select the MTD based on
#'                    the observed data. 
#' @param startdose the starting dose combination level for drug combination trial
#' @param titration set \code{titration=TRUE} to perform dose escalation with cohort size = 1 to accelerate dose escalation at the begining of the trial.
#' @param p.saf the highest toxicity probability that is deemed subtherapeutic (i.e. below the MTD)
#'              such that dose escalation should be undertaken.
#'              The default value is \code{p.saf=0.6*target}.
#' @param p.tox the lowest toxicity probability that is deemed overly toxic such that deescalation
#'              is required. The default value is \code{p.tox=1.4*target}.
#' @param cutoff.eli the cutoff to eliminate an overly toxic dose for safety. We recommend the
#'                   default value of (\code{cutoff.eli=0.95}) for general use.
#' @param extrasafe set \code{extrasafe=TRUE} to impose a more stringent stopping rule
#' @param offset a small positive number (between 0 and 0.5) to control how strict the stopping
#'               rule is when \code{extrasafe=TRUE}. A larger value leads to a more strict stopping
#'               rule. The default value \code{offset=0.05} generally works well.
#' @param ntrial the total number of trials to be simulated
#' @param mtd.contour set \code{mtd.contour=TRUE} to select the MTD contour (claiming multiple MTDs).
#'                    Otherwise, BOIN design is used to search for a single MTD.
#' @param boundMTD set \code{boundMTD=TRUE} to impose the condition: the isotonic estimate of toxicity
#'                 probability for the selected MTD must be less than de-escalation boundary.
#' @param seed the random seed for simulation
#'
#' @details The operating characteristics of the BOIN design are generated by
#' simulating trials under the prespecified true toxicity probabilities of the investigational dose
#' combinations. If \code{titration=TRUE}, we perform dose escalation with cohort size = 1 at the begining of the trial:
#' starting from \code{startdose}, if no toxicity is observed, we escalate the dose;
#' otherwise, the titration is completed and we switch to cohort size = \code{cohortsize}.
#' Titration accelerates the dose escalation and is useful when low doses are believed to be safe.
#'
#'
#' The BOIN design has two built-in stopping rules:
#' (1) stop the trial/subtrial if the lowest dose is eliminated due to toxicity, and no dose should
#' be selected as the MTD; and (2) stop the trial/subtrial and select the MTD if the number of
#' patients treated at the current dose reaches \code{n.earlystop}. The first stopping rule is a safety
#' rule to protect patients from the case in which all doses are overly toxic. The rationale for
#' the second stopping rule is that when there is a large number (i.e., \code{n.earlystop}) of
#' patients assigned to a dose, it means that the dose-finding algorithm has approximately converged.
#' Thus, we can stop the trial/subtrial early and select the MTD to save sample size and reduce the
#' trial duration.
#'
#'
#'  For some applications, investigators may prefer a more strict safety stopping rule than rule
#'  (1) for extra safety when the lowest dose is overly toxic.
#'  This can be achieved by setting \code{extrasafe=TRUE},
#'  which imposes the following more strict safety stopping rule:
#'  stop the trial if (i) the number of patients treated at the lowest dose \code{>=3},
#' and (ii) \eqn{Pr(toxicity\ rate\ of\ the\ lowest\ dose > \code{target} | data) > \code{cutoff.eli}-\code{offset}}.
#' As a tradeoff, the strong stopping rule will decrease the MTD selection percentage
#'  when the lowest dose actually is the MTD.
#'
#' @return \code{get.oc.comb()} returns the operating characteristics of the BOIN combination as a list. For the BOIN combination design, including:
#' (1) true toxicity probability at each dose level (\code{$p.true}),
#' (2) selection percentage at each dose level (\code{$selpercent}),
#' (3) the number of patients treated at each dose level (\code{$npatients})
#' (4) the number of toxicities observed at each dose level (\code{$ntox}),
#' (5) the total number of patients in the trial (\code{$totaln}),
#' (6) the total number of toxicities observed for the trial (\code{$totaltox})
#' (7) the pecentage of correct selection (\code{$pcs}),
#' (8) the total percentage of patients treated at the MTD (\code{$npercent}).
#' (9) the percentage of early stopping without selecting the MTD (\code{$percentstop})
#'
#'
#' @note We should avoid setting the values of \code{p.saf} and \code{p.tox} very close to the
#'      \code{target}. This is because the small sample sizes of typical phase I trials prevent us from
#'       differentiating the target DLT rate from the rates close to it. The default values provided by
#'       \code{get.oc()} are strongly recommended, and generally yield excellent operating characteristics.
#'
#'
#' @author Suyu Liu, Liangcai Zhang, Yanhong Zhou, and Ying Yuan
#'
#' @references Liu S. and Yuan, Y. (2015). Bayesian Optimal Interval Designs for Phase I Clinical
#'             Trials, \emph{Journal of the Royal Statistical Society: Series C}, 64, 507-523.
#'
#'            Lin R. and Yin, G. (2017). Bayesian Optimal Interval Designs for Dose Finding in
#'            Drug-combination Trials, \emph{Statistical Methods in Medical Research}, 26, 2155-2167.
#'
#'            Yan, F., Zhang, L., Zhou, Y., Pan, H., Liu, S. and Yuan, Y. (2020).BOIN: An R Package
#'            for Designing Single-Agent and Drug-Combination Dose-Finding Trials Using Bayesian Optimal
#'            Interval Designs. \emph{Journal of Statistical Software}, 94(13),1-32.<doi:10.18637/jss.v094.i13>.
#'
#'
#'            Zhang L. and Yuan, Y. (2016). A Simple Bayesian Design to Identify the Maximum
#'            Tolerated Dose Contour for Drug Combination Trials, \emph{Statistics in Medicine}, 35, 4924-4936.
#'
#' @seealso  Tutorial: \url{http://odin.mdacc.tmc.edu/~yyuan/Software/BOIN/BOIN2.6_tutorial.pdf}
#'
#'           Paper: \url{http://odin.mdacc.tmc.edu/~yyuan/Software/BOIN/paper.pdf}
#'
#' @examples
#'
#' ###### drug-combination trial ######
#'
#' ##### combination trial to find a single MTD  ######
#'
#' ## get the operating characteristics for BOIN design
#' p.true <- matrix(c(0.01,0.03,0.10,0.20,0.30,
#'                  0.03,0.05,0.15,0.30,0.60,
#'                  0.08,0.10,0.30,0.60,0.75), byrow=TRUE, ncol=5)
#'
#' oc.comb <- get.oc.comb(target=0.3, p.true, ncohort=20, cohortsize=3,
#'    n.earlystop=12, startdose=c(1,1), ntrial=100)
#'
#' summary(oc.comb)
#' plot(oc.comb)
#'
#'
#' ## get the operating characteristics with titration for BOIN design
#' oc.comb <- get.oc.comb(target=0.3, p.true, ncohort=20, cohortsize=3,
#'    n.earlystop=12, startdose=c(1,1), titration=TRUE, ntrial=100)
#' summary(oc.comb)
#' plot(oc.comb)
#'
#'
#'
#' @export
get.oc.comb.mod <- function (target, p.true, ncohort, cohortsize, preferred.doses, n.earlystop = NULL,
                             startdose = c(1, 1), titration = FALSE, p.saf = 0.6 * target,
                             p.tox = 1.4 * target, cutoff.eli = 0.95, extrasafe = FALSE,
                             offset = 0.05, ntrial = 1000, mtd.contour = FALSE, boundMTD=FALSE,seed = 6)
{
  get.oc.comb.boin <- function(target, p.true, ncohort, cohortsize, preferred.doses, 
                               n.earlystop = 100, startdose = c(1, 1), titration = FALSE,
                               p.saf = 0.6 * target, p.tox = 1.4 * target, cutoff.eli = 0.95,
                               extrasafe = FALSE, offset = 0.05, boundMTD=FALSE,ntrial = 1000) {
    JJ = nrow(p.true)
    KK = ncol(p.true)
    if (JJ > KK)
      stop("p.true should be arranged in a way (i.e., rotated) such that\n          the number of rows is less than or equal to the number of columns.")
    if (JJ > KK)
      p.true = t(p.true)
    if (target < 0.05) {
      stop("the target is too low!")
    }
    if (target > 0.6) {
      stop("the target is too high!")
      
    }
    if ((target - p.saf) < (0.1 * target)) {
      stop("the probability deemed safe cannot be higher than or too close to the target!")
    }
    if ((p.tox - target) < (0.1 * target)) {
      stop("the probability deemed toxic cannot be lower than or too close to the target!")
    }
    if (offset >= 0.5) {
      stop("the offset is too large!")
    }
    if (n.earlystop <= 6) {
      warning("the value of n.earlystop is too low to ensure good operating characteristics. Recommend n.earlystop = 9 to 18")
    }
    if (preferred.doses[startdose[1], startdose[2]]!=1){
      stop("Start dose must be preferred dose!")
    }
    ndose = length(p.true)
    npts = ncohort * cohortsize
    Y <- array(matrix(rep(0, length(p.true) * ntrial), dim(p.true)[1]),
               dim = c(dim(p.true), ntrial))
    N <- array(matrix(rep(0, length(p.true) * ntrial), dim(p.true)[1]),
               dim = c(dim(p.true), ntrial))
    dselect = matrix(rep(0, 2 * ntrial), ncol = 2) # selected dose default set to 0
    
    ## get boundary parameters -------------------------------------------------
    if (cohortsize > 1) {
      temp = get.boundary(target, ncohort, cohortsize,
                          n.earlystop=100, p.saf, p.tox, cutoff.eli, extrasafe)$full_boundary_tab
    }else {
      temp = get.boundary(target, ncohort, cohortsize,
                          n.earlystop=100, p.saf, p.tox, cutoff.eli, extrasafe)$boundary_tab
    }
    b.e = temp[2, ]
    b.d = temp[3, ]
    b.elim = temp[4, ]
    lambda1 = log((1 - p.saf)/(1 - target))/log(target *
                                                  (1 - p.saf)/(p.saf * (1 - target)))
    lambda2 = log((1 - target)/(1 - p.tox))/log(p.tox * (1 -
                                                           target)/(target * (1 - p.tox)))
    
    
    if (cohortsize == 1)
      titration = FALSE
    
    # simulation trials -------------------------------------------------------
    for (trial in 1:ntrial) {
      y <- matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2]) # DLT patients
      n <- matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2]) # patients treated
      earlystop = 0 # flag for elimination stop
      d = startdose
      elimi = matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2])
      elimi = elimi + (preferred.doses==-1) # not considered doses are flagged as eliminate
      ft=TRUE #flag used to determine whether or not to add cohortsize-1 patients to a dose for the first time when titration is triggered.
      if (titration) {
        tmpa = d[1]
        tmpb = d[2]
        y[tmpa, tmpb] <- (runif(1) < p.true[tmpa, tmpb])
        n[tmpa, tmpb] <- 1
        while (tmpa <= dim(p.true)[1] & tmpb <= dim(p.true)[2]) {
          if (tmpa == dim(p.true)[1] & tmpb == dim(p.true)[2]) {
            break
          }
          if (sum(y) == 1) {
            y[tmpa, tmpb] = 1
            break
          }
          if (tmpa < dim(p.true)[1] & tmpb < dim(p.true)[2]) {
            tmp.candidate = rbind(c(tmpa + 1, tmpb),
                                  c(tmpa, tmpb + 1))
            tmp.sel = rbinom(1, 1, prob = c(0.5, 0.5)) +
              1
            tmpa = tmp.candidate[tmp.sel, 1]
            tmpb = tmp.candidate[tmp.sel, 2]
          }
          else if (tmpa == dim(p.true)[1]) {
            tmpb = tmpb + 1
          }
          else {
            tmpa = tmpa + 1
          }
          y[tmpa, tmpb] <- (runif(1) < p.true[tmpa, tmpb])
          n[tmpa, tmpb] <- 1
        }
        if (sum(y) == 0) {
          d = c(dim(p.true)[1], dim(p.true)[2])
        }
        else {
          d = c(tmpa, tmpb)
        }
      }
      for (pp in 1:ncohort) {
        
        ## generate DLT for enrolled patient in this cohort -----------------------
        if (titration & n[d[1], d[2]] < cohortsize & ft) {
          ft=FALSE
          
          y[d[1], d[2]] = y[d[1], d[2]] + sum(runif(cohortsize -
                                                      1) < p.true[d[1], d[2]])
          n[d[1], d[2]] = n[d[1], d[2]] + cohortsize -1
        }
        else {
          y[d[1], d[2]] = y[d[1], d[2]] + sum(runif(cohortsize) <
                                                p.true[d[1], d[2]])
          n[d[1], d[2]] = n[d[1], d[2]] + cohortsize
        }
        
        
        
        nc = n[d[1], d[2]] #the updated number of patients treated for this dose
        
        ## examine elimination -------------------------------------------------
        if (!is.na(b.elim[nc])) { # if eliminated boundary exists
          
          if (y[d[1], d[2]] >= b.elim[nc]) { # if number of DLTs in current dose exceeds elimination boundary
            
            
            for (i in min(d[1], dim(p.true)[1]):dim(p.true)[1]) { # set elimination status for current and higher dose to 1
              for (j in min(d[2], dim(p.true)[2]):dim(p.true)[2]) {
                elimi[i, j] = 1
              }
            }
            
            if (d[1] == 1 && d[2] == 1) { # if current dose is lowest dose, early stop
              d = c(99, 99)
              earlystop = 1
              break
            }
          }
          
          
          if (extrasafe) {
            if (d[1] == 1 && d[2] == 1 && n[1, 1] >=
                3) {
              if (1 - pbeta(target, y[1, 1] + 1, n[1,
                                                   1] - y[1, 1] + 1) > cutoff.eli - offset) {
                d = c(99, 99)
                earlystop = 1
                break
              }
            }
          }
        }
        
        ## check if need to stop the trial ----------------------------------------
        if (n[d[1],d[2]] >= n.earlystop  &&  # MUST: current dose reach early stop cohort size and satisfy one of the following:
            (y[d[1],d[2]]>b.e[n[d[1],d[2]]] || #  current dose reach elimination boundary
             (d[1]==dim(p.true)[1] && d[2]==dim(p.true)[2]) || #  current dose is highest dose
             ( d[1]==dim(p.true)[1] && d[2]<dim(p.true)[2] && elimi[d[1],d[2]+1]==1 ) || # higher dose eliminated in one direction, current dose reach highest dose in one drug
             ( d[1]<dim(p.true)[1] && d[2]==dim(p.true)[2] && elimi[d[1]+1,d[2]]==1 ) || 
             ( d[1]<dim(p.true)[1] && d[2]<dim(p.true)[2] && elimi[d[1]+1,d[2]]==1 && elimi[d[1],d[2]+1]==1 ) )  && # higher dose eliminated in both directions 
            (y[d[1],d[2]]<b.d[n[d[1],d[2]]] || (d[1]==1 && d[2]==1) ) ) break; # MUST: DLTs below de-escalation boundary or current dose is the lowest dose
        
        
        ## escalate ---------------------------------
        if (y[d[1], d[2]] <= b.e[nc]) {  
          elevel = matrix(c(1, 0, 0, 1), 2) # Two potential escalation directions
          pr_H0 = rep(0, length(elevel)/2) # to store probabilities for two potential dose
          nn = pr_H0 # store number of patients treated at each candidate dose
          prefer = rep(0, length(elevel)/2) # to store preference for two candidate dose
          for (i in seq(1, length(elevel)/2, by = 1)) { # check for two candidates
            if (d[1] + elevel[1, i] <= dim(p.true)[1] && # check if candidate dose is within the dose matrix
                d[2] + elevel[2, i] <= dim(p.true)[2]) {
              prefer[i] = preferred.doses[d[1] + elevel[1, i], d[2] + elevel[2, i]]
              if (elimi[d[1] + elevel[1, i], d[2] + elevel[2,
                                                           i]] == 0) { # if candidate has not been eliminated
                yn = y[d[1] + elevel[1, i], d[2] + elevel[2,
                                                          i]] # observed DLTs at candidate dose
                nn[i] = n[d[1] + elevel[1, i], d[2] +
                            elevel[2, i]] # observed number of patients at candidate dose
                pr_H0[i] <- pbeta(lambda2, yn + 0.5, nn[i] - yn + 0.5) -
                  pbeta(lambda1, yn + 0.5, nn[i] - yn + 0.5) # prob of within target DLT boundary
                
                
              }
            }
          }
          
          pr_H0 = pr_H0 + nn * 5e-04 + ifelse(prefer==-1, -99,0) # negative prob for not considered dose # avoid zero prob if candidate dose have patients
          if (max(pr_H0) == 0) { ##!!! no valid escalation, but not gonna happen due to previous command?---------------------------
            d = d
          }
          else { ## select candidate dose with higher prob; if equal, then pick the preferred dose; if equally preferred, choose randomly
            if(pr_H0[1]!=pr_H0[2]){
              k = which(pr_H0 == max(pr_H0))
              d = d + c(elevel[1, k], elevel[2, k])
            }else{
              k = which(prefer == max(prefer))[as.integer(runif(1) *
                                                            length(which(pr_H0 == max(pr_H0))) + 1)]
              if(prefer[k]==-1) {d = d} # if not considered, stay
              else{d = d + c(elevel[1, k], elevel[2, k])}
            }
          }
        }
        ## de-escalate ----------------------------
        else if (y[d[1], d[2]] >= b.d[nc]) { 
          delevel = matrix(c(-1, 0, 0, -1), 2)
          pr_H0 = rep(0, length(delevel)/2)
          nn = pr_H0
          prefer = rep(0, length(elevel)/2) # to store preference for two candidate dose
          for (i in seq(1, length(delevel)/2, by = 1)) {
            if (d[1] + delevel[1, i] > 0 && d[2] + delevel[2,
                                                           i] > 0) {
              yn = y[d[1] + delevel[1, i], d[2] + delevel[2,
                                                          i]]
              nn[i] = n[d[1] + delevel[1, i], d[2] +
                          delevel[2, i]]
              pr_H0[i] = pbeta(lambda2, yn + 0.5, nn[i] - yn + 0.5) - 
                pbeta(lambda1, yn + 0.5, nn[i] - yn + 0.5)
              
              prefer[i] = preferred.doses[d[1] + delevel[1, i], d[2] + delevel[2, i]]
            }
          }
          pr_H0 = (pr_H0 + nn * 5e-04) + ifelse(prefer==-1, -99,0) # negative prob for not considered dose
          
          if (max(pr_H0) == 0) {
            d = d
          }
          else {
            if(pr_H0[1]!=pr_H0[2]){
              k = which(pr_H0 == max(pr_H0))
              d = d + c(delevel[1, k], delevel[2, k])
            }else{
              k = which(prefer == max(prefer))[as.integer(runif(1) *
                                                            length(which(pr_H0 == max(pr_H0))) + 1)]
              if(prefer[k]==-1) {d = d} # if not considered, stay
              else{d = d + c(delevel[1, k], delevel[2, k])}
            }
          }
        }
        else { ## stay ----------------------------------------------------------
          d = d
        }
        
        
      }
      Y[, , trial] = y
      N[, , trial] = n
      if (earlystop == 1) {
        dselect[trial, ] = c(99, 99)
      }else {
        selcomb = select.mtd.comb.boin(target, n, y,
                                       cutoff.eli, extrasafe, offset,
                                       boundMTD=boundMTD,p.tox=p.tox,mtd.contour = FALSE)$MTD
        dselect[trial, 1] = selcomb[1]
        dselect[trial, 2] = selcomb[2]
      }
    }
    selpercent = matrix(rep(0, ndose), dim(p.true)[1], dim(p.true)[2])
    nptsdose = apply(N, c(1, 2), mean, digits = 2, format = "f")
    ntoxdose = apply(Y, c(1, 2), mean, digits = 2, format = "f")
    for (i in 1:dim(p.true)[1]) for (j in 1:dim(p.true)[2]) {
      {
        selpercent[i, j] = sum(dselect[, 1] == i & dselect[,
                                                           2] == j)/ntrial * 100
      }
    }
    if (JJ <= KK) {
      rownames(p.true) = paste("DoseA", 1:dim(p.true)[1],
                               sep = "")
      colnames(p.true) = paste("DoseB", 1:dim(p.true)[2],
                               sep = "")
      rownames(selpercent) = paste("DoseA", 1:dim(p.true)[1],
                                   sep = "")
      colnames(selpercent) = paste("DoseB", 1:dim(p.true)[2],
                                   sep = "")
      out = list(p.true = round(p.true, 2), selpercent = round(selpercent,2),
                 npatients = round(apply(N, c(1, 2), mean),2), ntox = round(apply(Y, c(1, 2), mean), 2),
                 totaltox = round(sum(Y)/ntrial, 1), totaln = round(sum(N)/ntrial,1),
                 pcs = paste(round(sum(selpercent[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)]),1), "%", sep = ""),
                 npercent = paste(round(sum(nptsdose[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)])/sum(nptsdose) *100, 1), "%", sep = ""),
                 percentstop=100-sum(round(selpercent,2)),flowchart = FALSE)
      rownames(out$npatients) = paste("DoseA", 1:dim(p.true)[1],
                                      sep = "")
      colnames(out$npatients) = paste("DoseB", 1:dim(p.true)[2],
                                      sep = "")
      rownames(out$ntox) = paste("DoseA", 1:dim(p.true)[1],
                                 sep = "")
      colnames(out$ntox) = paste("DoseB", 1:dim(p.true)[2],
                                 sep = "")
      
      return(out)
    }
    else {
      colnames(p.true) = paste("DoseB", 1:dim(t(p.true))[1],
                               sep = "")
      rownames(p.true) = paste("DoseA", 1:dim(t(p.true))[2],
                               sep = "")
      colnames(selpercent) = paste("DoseB", 1:dim(t(p.true))[1],
                                   sep = "")
      rownames(selpercent) = paste("DoseA", 1:dim(t(p.true))[2],
                                   sep = "")
      colnames(npatients) = paste("DoseB", 1:dim(t(p.true))[1],
                                  sep = "")
      rownames(npatients) = paste("DoseA", 1:dim(t(p.true))[2],
                                  sep = "")
      colnames(ntox) = paste("DoseB", 1:dim(t(p.true))[1],
                             sep = "")
      rownames(ntox) = paste("DoseA", 1:dim(t(p.true))[2],
                             sep = "")
      out = list(p.true = round(t(p.true), 2), selpercent = round(t(selpercent),2),
                 npatients = round(t(apply(N, c(1, 2), mean)), 2), ntox = round(t(apply(Y, c(1, 2), mean)),2),
                 totaltox = round(sum(Y)/ntrial, 1), totaln = round(sum(N)/ntrial,1), pcs = paste(round(sum(selpercent[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)]),
                                                                                                        1), "%"), npercent = paste(round(sum(nptsdose[which(abs(p.true -target) == min(abs(p.true - target)), arr.ind = TRUE)])/sum(nptsdose) *100, 1), "%"),
                 percentstop=100-sum(round(selpercent,2)),
                 flowchart = FALSE)
      
      return(out)
    }
  }
  select.mtd.comb.boin <- function(target, npts, ntox, cutoff.eli = 0.95,
                                   extrasafe = FALSE, offset = 0.05,
                                   boundMTD=FALSE,p.tox=1.4*target,
                                   mtd.contour = FALSE) {
    lambda_d = log((1 - target)/(1 - p.tox))/log(p.tox * (1 -target)/(target * (1 - p.tox)))
    y = ntox
    n = npts
    if (nrow(n) > ncol(n) | nrow(y) > ncol(y)) {
      stop("npts and ntox should be arranged in a way (i.e., rotated) such that for each of them, the number of rows is less than or equal to the number of columns.")
    }
    elimi = matrix(0, dim(n)[1], dim(n)[2])
    if (extrasafe) {
      if (n[1, 1] >= 3) {
        if (1 - pbeta(target, y[1, 1] + 1, n[1, 1] -
                      y[1, 1] + 1) > cutoff.eli - offset) {
          elimi[, ] = 1
        }
      }
    }
    for (i in 1:dim(n)[1]) {
      for (j in 1:dim(n)[2]) {
        if (n[i, j] >= 3) {
          if (1 - pbeta(target, y[i, j] + 1, n[i, j] -
                        y[i, j] + 1) > cutoff.eli) {
            elimi[i:dim(n)[1], j] = 1
            elimi[i, j:dim(n)[2]] = 1
            break
          }
        }
      }
    }
    
    selectdose=NULL
    if (elimi[1] == 1) {
      
      selectdose = c(99, 99)
      selectdoses = matrix(selectdose, nrow = 1)
      
    }else {
      
      phat = (y + 0.05)/(n + 0.1)
      phat = Iso::biviso(phat, n + 0.1, warn = TRUE)[,
      ]
      phat.out = phat
      phat.out[n == 0] = NA
      phat[elimi == 1] = 1.1
      phat = phat * (n != 0) + (1e-05) * (matrix(rep(1:dim(n)[1],
                                                     each = dim(n)[2], len = length(n)), dim(n)[1],
                                                 byrow = T) + matrix(rep(1:dim(n)[2], each = dim(n)[1],
                                                                         len = length(n)), dim(n)[1]))
      
      
      if(boundMTD){
        
        if(all(phat[n!=0]>=lambda_d)){
          selectdose = c(99, 99)
          
          
          selectdoses = matrix(selectdose, nrow = 1)
        }else{
          phat[phat>=lambda_d]=10}}
      
      if(is.null(selectdose)){
        
        phat[n == 0] = 10
        selectdose = which(abs(phat - target) == min(abs(phat -
                                                           target)), arr.ind = TRUE)
        if (length(selectdose) > 2)
          selectdose = selectdose[1, ]
        aa = function(x) as.numeric(as.character(x))
        if (mtd.contour == TRUE) {
          selectdoses = cbind(row = 1:dim(n)[1], col = rep(99,
                                                           dim(n)[1]))
          for (k in dim(n)[1]:1) {
            kn = n[k, ]
            ky = y[k, ]
            kelimi = elimi[k, ]
            kphat = phat[k, ]
            if (kelimi[1] == 1 || sum(n[kelimi == 0]) ==
                0) {
              kseldose = 99
            }
            else {
              adm.set = (kn != 0) & (kelimi == 0)
              adm.index = which(adm.set == T)
              y.adm = ky[adm.set]
              n.adm = kn[adm.set]
              selectd = sort(abs(kphat[adm.set] - target),
                             index.return = T)$ix[1]
              kseldose = adm.index[selectd]
            }
            selectdoses[k, 2] = ifelse(is.na(kseldose),
                                       99, kseldose)
            if (k < dim(n)[1])
              if (selectdoses[k + 1, 2] == dim(n)[2])
                selectdoses[k, 2] = dim(n)[2]
            if (k < dim(n)[1])
              if (aa(selectdoses[k + 1, 2]) == dim(n)[2] &
                  aa(selectdoses[k + 1, 2]) == aa(selectdoses[k,
                                                              2]))
                selectdoses[k, 2] = 99
          }
        }
        else {
          selectdoses = matrix(99, nrow = 1, ncol = 2)
          selectdoses[1, ] = matrix(selectdose, nrow = 1)
        }
        selectdoses = matrix(selectdoses[selectdoses[, 2] !=
                                           99, ], ncol = 2)
      }
      
      colnames(selectdoses) = c("DoseA", "DoseB")
    }
    if (mtd.contour == FALSE) {
      if (selectdoses[1, 1] == 99 && selectdoses[1, 2] ==
          99) {
        
        out=list(target = target, MTD = 99, p_est = matrix(NA,
                                                           nrow = dim(npts)[1], ncol = dim(npts)[2]))
        
        return(out)
      }
      else {
        out=list(target = target, MTD = selectdoses,
                 p_est = round(phat.out, 2))
        
        return(out)
      }
    }
    else {
      if (length(selectdoses) == 0) {
        out=list(target = target, MTD = 99, p_est = matrix(NA,
                                                           nrow = dim(npts)[1], ncol = dim(npts)[2]))
        
        
        return(out)
        
      }
      else {
        out=list(target = target, MTD = selectdoses,
                 p_est = round(phat.out, 2))
        
        return(out)
      }
    }
  }
  
  set.seed(seed)
  JJ = nrow(p.true)
  KK = ncol(p.true)
  if (JJ > KK) {
    stop("p.true should be arranged in a way (i.e., rotated) such that the number of rows is less than or equal to the number of columns.")
    
  }
  if (mtd.contour == FALSE) {
    if (is.null(n.earlystop) == TRUE)
      n.earlystop = 100
    if (n.earlystop <= 6) {
      warning("the value of n.earlystop is too low to ensure good operating characteristics. Recommend n.earlystop = 9 to 18 ")
    }
    if (length(ncohort) > 1) {
      warning("ncohort is the total number of cohorts for the trial. Please enter a scalar.")
    }
    if (((JJ * KK) <= 4) & (sum(ncohort) <= 6)) {
      warning("the sample size is too small, which may lead to poor operating characteristics. Suggest to increase the number of cohort.")
    }
    if (((JJ * KK) > 4) & (sum(ncohort) <= 8)) {
      warning("the sample size is too small, which may lead to poor operating characteristics. Suggest to increase the number of cohort.")
    }
    out=get.oc.comb.boin(target = target, p.true = p.true,
                         ncohort = sum(ncohort), cohortsize = cohortsize,
                         preferred.doses = preferred.doses,
                         n.earlystop = n.earlystop, startdose = startdose,
                         titration = titration,
                         p.saf = p.saf, p.tox = p.tox,
                         cutoff.eli = cutoff.eli, extrasafe = extrasafe,
                         offset = offset,boundMTD=boundMTD,
                         ntrial = ntrial)
    class(out)<-"boin"
    return(out)
  }
  
}